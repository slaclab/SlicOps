// Interface to UI API service
//
// Copyright (c) 2024 The Board of Trustees of the Leland Stanford Junior University, through SLAC National Accelerator Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy).  All Rights Reserved.
// http://github.com/slaclab/slicops/LICENSE

import { Injectable } from '@angular/core';
import { WebSocketSubject, webSocket } from 'rxjs/webSocket';
import { Observable, Subject, Subscription } from 'rxjs';
import { encode, decode } from '@msgpack/msgpack';
import { LogService } from 'log.service';

type ResultHandler = (api_result: any) => void;

type APIErrorHandler = (api_error: string) => void;

type ReplyMsg = {
    api_error: string;
    call_id: number;
    api_result: any;
};

type AuthResult = {
    client_id: string;
};

class Call {
    call_id: number;
    api_name: string;
    resultHandler: ResultHandler;
    destroyed: boolean = false;
    msg: any;
    apiErrorHandler?: APIErrorHandler;

    constructor(call_id: number, api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) {
        super();
        this.call_id = call_id;
        this.api_name = api_name;
        this.resultHandler = resultHandler;
        this.apiErrorHandler? = apiErrorHandler?;
        this.msg = encode({
            call_id: c.call_id,
            api_name: c.api_name,
            api_args: c.api_args,
        });

    }

    destroy() {
        this.destroyed = true;
    }

    handleResult(api_result: any) {
        this.resultHandler(api_result);
        this.destroy();
    }
}

//TODO(robnagler) needs to be generated by server
const AUTH_API_NAME = 'pykern_http_auth';

const AUTH_API_VERSION = 1;


@Injectable({
    providedIn: 'root'
})
export class APIService {
    #authOK: boolean = false;
    #call_id: number = 0;
    #client_id: string | null = null;
    //TODO(robnagler) registration interface
    #errorHandler = this.#defaultErrorHandler;
    #pendingCalls: Map<number, Call> = new Map<number,Call>();
    #socket: Websocket | null = null;
    #socketRetryBackoff: int = 0;
    #unsentCalls: Array<Call> = new Array<Call>;

    constructor(logService: LogService) {
        this.log = logService;
        this.log.dbg('create websocket');
        this.#socketOpen();
    }

    // Send a message to the server
    call(api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) : Call {

        rv = new Call(++this.#call_id, api_name, api_args, resultHandler, apiErrorHandler?);
        this.#unsentCalls.push(rv);
        this.#send();
        return rv;
    }

    ngOnDestroy() {
        this.log.dbg('destroy');
        if (this.#socket) {
            this.#socket.close();
            this.#socket = null;
        }
        this.#clearCalls('ngOnDestroy');
    }

    #authError(error: string) {
        // If there is a protocol error, this will retry forever. That would be a major problem
        // which is not fixable or really detectable. Likely case is the socket closed before auth
        // completed.
        this.#socket.close();
        this.#socketOnError(error);
    }

    #authResult(api_result: AuthResult) {
        this.#client_id = api_result.client_id;
        this.#authOK = true;
        this.#send();
    }

    #clearCalls(error: string) {
        a = this.#pendingCalls.values() + this.#unsentCalls;
        this.#pendingCalls = new Map<number,Call>();
        this.#unsentCalls = new Array<Call>();
        for (const c of a) {
            if (c.destroyed) {
                continue;
            }
            if (c.apiErrorHandler?) {
                c.apiErrorHandler?(error);
            }
            c.destroy();
        }
    }


    #defaultErrorHandler(call?: Call, error: any) {
        m = ['error', error];
        if (call?) {
            m.push(c.call_id, c.api_name);
        }
        this.log.error(m);
    }

    #findCall(call_id: number, calls: Map<number, Call>) : Call | null {
        if (! calls.has(call_id)) {
            return null;
        }
        const rv = calls.get(call_id);
        calls.delete(call_id);
        if (rv.destroyed) {
            return null;
        }
        return rv;
    }

    #send() {
        if (! this.#socket || this.#unsentCalls.length <= 0 || this.#socket.readyState !== WebSocket.OPEN || ! this.#authOK) {
            return;
        }
        while (this.#unsentCalls.length > 0) {
            self.#sendOne(this.#unsentCalls.shift());
        }
    };

    #sendOne(call: Call) {
        if (call.destroyed) {
            continue;
        }
        this.log.dbg(['call', call.call_id, call.api_name]);
        this.#pendingCalls.set(call.call_id, call);
        this.#socket.send(call.msg);
    }

    #socketOnError(event: any) {
        // close: event.code : short, event.reason : str, wasClean : bool
        // error: app specific
        this.#socket = null;
        if (this.#socketRetryBackoff <= 0) {
            this.#socketRetryBackoff = 1;
            this.#errorHandler(['WebSocket failed', event]);
            self.#clearCalls(event.wasClean ? 'socket closed' : 'socket error');
        }
        setTimeout(this.#socketOpen, this.#socketRetryBackoff * 1000);
        if (this.#socketRetryBackoff < 60) {
            this.#socketRetryBackoff *= 2;
        }
    };

    #socketOnMessage(event: MessageEvent) {
        const m = decode(event.data) as ReplyMsg;
        if (! (c = this.#findCall(this.#pendingCalls, m.call_id))) {
            this.log.dbg(['call not found, ignoring', m.call_id])
            return;
        }
        if (m.api_error) {
            if (c.apiErrorHandler?) {
                c.apiErrorHandler?(api_error);
            }
            else {
                this.#apiErrorHandler(c, api_error);
            }
            c.destroy();
        }
        else {
            this.log.dbg(['api_result', m.api_result, c.api_name, c.call_id]);
            c.handleResult(m.api_result);
        }
    };

    #socketOnOpen(event: Event) {
        this.#socketRetryBackoff = 0;
        this.call(
            AUTH_API_NAME,
            {
                client_id: #this.client_id,
                // No token, because any value would have to come from the server,
                // and therefore would be discoverable.
                token: null,
                version: AUTH_API_VERSION,
            },
            this.#authResult,
            this.#authError,
        )
        this.#sendOne(this.#unsentCalls.pop());
    };

    #socketOpen() {
        let socket: WebSocket | null = null;
        try {
            s = new WebSocket('/api-v1')
            s.onclose = this.#socketOnError;
            s.onerror = this.#socketOnError;
            s.onmessage = this.#socketOnMessage;
            s.onopen = this.#socketOnOpen;
            this.#authOK = false;
            this.#socket = s;
        } catch (err) {
            this.#socketOnError(err);
            return null;
        }
    };
}
