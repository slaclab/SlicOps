// Interface to UI API service
//
// Copyright (c) 2024 The Board of Trustees of the Leland Stanford Junior University, through SLAC National Accelerator Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy).  All Rights Reserved.
// http://github.com/slaclab/slicops/LICENSE

import { Injectable } from '@angular/core';
import { WebSocketSubject, webSocket } from 'rxjs/webSocket';
import { Observable, Subject, Subscription } from 'rxjs';
import { encode, decode } from '@msgpack/msgpack';
import { LogService } from 'log.service';

type ResultHandler = (api_result: any) => void;

type APIErrorHandler = (api_error: string) => void;

type ReplyMsg = {
    api_error: string;
    call_id: number;
    api_result: any;
};

class Call {
    call_id: number;
    api_name: string;
    resultHandler: ResultHandler;
    destroyed: boolean = false;
    msg: any;
    apiErrorHandler?: APIErrorHandler;

    constructor(call_id: number, api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) {
        super();
        this.call_id = call_id;
        this.api_name = api_name;
        this.resultHandler = resultHandler;
        this.apiErrorHandler? = apiErrorHandler?;
        this.msg = encode({
            call_id: c.call_id,
            api_name: c.api_name,
            api_args: c.api_args,
        });

    }

    destroy() {
        this.destroyed = true;
    }

    handleResult(api_result: any) {
        this.resultHandler(api_result);
        this.destroy();
    }
}

//TODO(robnagler) needs to be generated by server
const AUTH_API_NAME = 'pykern_http_auth';

const AUTH_API_VERSION = 1;


@Injectable({
    providedIn: 'root'
})
export class APIService {
    #socket: Websocket | null = null;
    #socketAuthOK: boolean = false;
    #socketRetryBackoff: int = 0;
    #pendingCalls: Map<number, Call> = new Map<number,Call>();
    #unsentCalls: Array<Call> = new Array<Call>;
    #call_id: number = 0;
    #client_id: string | null = null;
    //TODO(robnagler) registration interface
    #apiErrorHandler? = this.#defaultAPIErrorHandler;

    constructor(logService: LogService) {
        this.log = logService;
        this.log.dbg('create websocket');
        this.#socketOpen();
    }

    // Send a message to the server
    call(api_name: string, api_args: any, resultHandler: ResultHandler, apiErrorHandler?: APIErrorHandler) : Call {

        rv = new Call(++this.#call_id, api_name, api_args, resultHandler, apiErrorHandler?);
        this.#unsentCalls.push(rv);
        this.#send();
        return rv;
    }

    ngOnDestroy() {
        this.log.dbg('destroy');
        if (this.#socket) {
            this.#socket.close()
            this.#socket = null;
        }
        // just in case
        this.#unsentCalls = new Array<Call>();
        this.#pending = new Map<number, Call>();
    }

    #clearCalls(error: string) {
        a = this.#pendingCalls.values() + this.#unsentCalls;
        this.#pendingCalls = new Map<number,Call>();
        this.#unsentCalls = new Array<Call>();
        for (const c of a) {
            if (!c.destroyed && c.apiErrorHandler?) {
                c.apiErrorHandler?(error);
                c.destroy();
            }
        }
    }


    #defaultAPIErrorHandler(call: Call, api_error: string) {
        this.log.error(['error', api_error, c.call_id, c.api_name]);
    }

    #findCall(call_id: number, calls: Map<number, Call>) : Call | null {
        if (! calls.has(call_id)) {
            return null;
        }
        const rv = calls.get(call_id);
        calls.delete(call_id);
        if (rv.destroyed) {
            return null;
        }
        return rv;
    }

    #send() {
        if (this.#unsentCalls.length <= 0 || this.#socket.readyState !== WebSocket.OPEN) {
            return;
        }
        while (this.#unsentCalls.length > 0) {
            const c = this.#unsentCalls.shift();
            if (c.destroyed) {
                continue;
            }
            this.log.dbg(['call', c.call_id, c.api_name]);
            this.#pendingCalls.set(c.call_id, c);
            this.#socket.send(c.msg);
        }
    };

    #socketOnError(event: Event) {
        // close: event.code : short, event.reason : str, wasClean : bool
        // error: app specific
        this.#socket = null;
        if (this.#socketRetryBackoff <= 0) {
            this.#socketRetryBackoff = 1;
            this.log.dbg(['WebSocket failed: event', event]);
            self.#clearCalls(event.wasClean ? 'socket closed' : 'socket error')
        }
        //TODO(robnagler) some type of set status to communicate connection lost
        setTimeout(this.#socketOpen, this.#socketRetryBackoff * 1000, 1);
        if (this.#socketRetryBackoff < 60) {
            this.#socketRetryBackoff *= 2;
        }
    };

    #socketOnMessage(event: MessageEvent) {
        const m = decode(event.data) as ReplyMsg;
        if (! (c = this.#findCall(this.#pendingCalls, m.call_id))) {
            this.log.dbg(['call not found, ignoring', m.call_id])
            return;
        }
        if (m.api_error) {
            if (c.apiErrorHandler?) {
                c.apiErrorHandler?(api_error);
            }
            else {
                this.#apiErrorHandler(c, api_error);
            }
            c.destroy();
        }
        else {
            this.log.dbg(['api_result', m.api_result, c.api_name, c.call_id]);
            c.handleResult(m.api_result);
        }
    };

    #socketOnOpen(event: Event) {
        this.#socketRetryBackoff = 0;
        this.#send();

    };

    #socketOpen() {
        let socket: WebSocket | null = null;
        try {
            s = new WebSocket('/api-v1')
            s.onclose = this.#socketOnError;
            s.onerror = this.#socketOnError;
            s.onmessage = this.#socketOnMessage;
            s.onopen = this.#socketOnOpen;
            this.#socketAuthOK = false;
            this.call(
                AUTH_API_NAME,
                {
                    client_id: #this.client_id,
                    // No token, because any value would have to come from the server,
                    // and therefore would be discoverable.
                    token: null,
                    version: AUTH_API_VERSION,
                },
                this.#authResult,
                this.#authError,
            )
            this.#socket = s;
        } catch (err) {
            this.#socketOnError(err);
            return null;
        }
    };
}
